{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TUNE - Topologic UntaNgling 2D mEsher","text":"<p>The aim of this project is to provide an environment to implement  Reinforcement Learning algorithms that aim to topologically modify a 2D mesh. More specifically, we implement the work of  A. Narayanana, Y. Pan, and P.-O. Persson, which is described  in \"Learning topological operations on meshes with application to  block decomposition of polygons\" (see arxiv article and presentation).</p>"},{"location":"#useful-tools-for-developing-in-tune","title":"Useful tools for developing in TUNE","text":"<p>In order to develop in this project, please take a look to useful software we use on the  development tools page.</p>"},{"location":"actions/","title":"Triangular Actions","text":""},{"location":"actions/#flip","title":"Flip","text":"<p>The flip operation flips an inner edge adjacent to two triangles. This selected edge is then deleted and replaced by an edge on the opposite diagonal. The following diagram shows the steps involved in flipping strand d.</p> <p></p> <p>However, in some configurations, flip action can lead to problematic configurations. That's why we choose to constraint flip action in these situations :</p> <ul> <li>Boundary darts : When a dart is on boundary of the mesh, we should'nt flip the edge. We can check this condition by looking if the dart to flip has a twin dart.</li> <li>Adjacency too high : When nodes C and D already have an adjacency higher than 10, flip is not possible. </li> <li>Configuration who tends to imply edge reversal: To detect these situations, we look a the type of quad formed by the two adjacent faces, i.e. quad ADBC.<ul> <li>concave quad: When the quad is concave, flip operation necessarily lead to an edge reversal. We constraint it.   In the figures below, we can see when flipping dart 18 a face reversal.</li> </ul> </li> </ul> <p> </p> <pre><code>* **triangular quad:** This configuration should be avoided, as it results in the creation of a degenerate (flat) triangle. As illustrated in the figures below, flipping dart 0 leads to a flattened face between nodes 2, 0, and 7.\n</code></pre> <p> </p> <p>The only configuration we accept is convexe quads</p>"},{"location":"actions/#split","title":"Split","text":"<p>The split operation split an inner edge adjacent to two triangles. A node is added in the middle of the edge and two faces are created.</p> <p></p> <p>However, in some configurations, split action can also lead to problematic configurations. That's why we choose to constraint split action in these situations :</p> <ul> <li>Boundary darts : When a dart is on boundary of the mesh, we decide to prohibit it. It can be possible if we add another boundary node, but we choose to not touch mesh boundaries. We can check this condition by looking if the dart to split has a twin dart.</li> <li>Adjacency too high : When nodes C and D already have an adjacency higher than 10, split is not possible. </li> <li>Configuration who tends to imply null darts: As other actions are restricted to not allow flat faces, or reversed faces, split action can be performed on each configuration, see figure xxx.</li> </ul> <p> </p>"},{"location":"actions/#collapse","title":"Collapse","text":"<p>The collapse operation deletes an inner edge and also implies the deletion of its two adjacent faces F1 and F2.</p> <p></p> <p>However, in some configurations, collapse action can also lead to problematic configurations. That's why we choose to constraint collapse action in these situations :</p> <ul> <li>Boundary darts : When a dart is on boundary of the mesh, we decide to prohibit it. We choose to not touch mesh boundaries. We can check this condition by looking if the dart to split has a twin dart.</li> <li>Adjacency too high : When nodes A already has an adjacency higher than 10, collapse is not possible. </li> <li>Configuration who tends to imply edge reversal: To detect these situations, we look a the type of darts in the surrounding. When there are some darts with concave surrounding, collapse action can lead to edge reversal.</li> </ul> <p> </p>"},{"location":"actions/#quadrangular-actions","title":"Quadrangular Actions","text":""},{"location":"actions/#flip_1","title":"Flip","text":"<p>The flip action can be decomposed as follows:</p> <ul> <li>Check whether the dart <code>d</code> exists.  </li> <li>Update the beta1 relations.  </li> <li>Update the links from nodes <code>n1</code> and <code>n2</code>,  if they were previously linked to the flipped dart.  </li> <li>Update the links from faces <code>F1</code> and <code>F2</code>, if they were previously linked to the flipped dart.  </li> <li>Update the node links for <code>d</code> and <code>d2</code>.  </li> <li>Update the face links depending on the orientation (darts which change of face):</li> <li>If counterclockwise: update links for <code>d1</code> and <code>d21</code>.  </li> <li>If clockwise: update links for <code>d2111</code> and <code>d111</code>.  </li> <li>Update the scores of the nodes.</li> </ul>"},{"location":"actions/#split_1","title":"Split","text":"<p>The split action can be decomposed as follows:</p> <ul> <li>Check whether the dart <code>d</code> exists.  </li> <li>Create a new node n10 in the middle of [n1,n2]</li> <li>Update node links of <code>d</code> and <code>d21</code>, they are now linked to <code>n10</code></li> <li>Create a new face with yellow darts</li> <li>Update the beta2 relations (<code>d1112</code>, <code>d111</code>,<code>d212</code>, <code>d21</code>).</li> <li>Update the scores of the nodes.</li> </ul>"},{"location":"actions/#collapse_1","title":"Collapse","text":"<p>The collapse action can be decomposed as follows:</p> <ul> <li>Check whether the dart <code>d</code> exists.  </li> <li>Save the score of node <code>n1</code> for later computation.  </li> <li>If <code>n3</code> is not on the boundary, move its coordinates to the midpoint between <code>n3</code> and <code>n1</code>.  </li> <li>Check if nodes <code>n2</code> and <code>n4</code> are linked to the dart being deleted. If so, reassign their links to existing darts (node <code>n3</code> will be checked later).  </li> <li>Delete the face associated with <code>d</code>, along with its related darts.  </li> <li>Reassign all darts previously linked to <code>n1</code> so they now point to <code>n3</code>.  </li> <li>Link the dart associated with <code>n3</code> to an existing node.  </li> <li>Update the beta2 relations (<code>d2</code>/<code>d12</code>, <code>d112</code>/<code>d1112</code>).  </li> <li>Recalculate the scores of the affected nodes.</li> </ul>"},{"location":"cmap/","title":"Combinatorial maps","text":"<p>2-dimensional combinatorial maps, or 2-C-maps for short,  are topological structures that allow us to represent and  handle 2D oriented manifold surfaces. In order to introduce this model, let us consider the following picture: - On the top left, the structure is made of 3 faces, or 2-cells: one quadrilateral, and two triangles - On the top right, the cells are explicitly named and in particular, we show that faces and nodes are considered. - In fact, faces are usually defined and built from a set of nodes. Here, for instance, the face f1 is defined from  the ordered list of nodes : n1, n6, n5, n2. To have whole well-oriented structure, faces must be oriented in the same  direction (see bottom left). - The 2-C-map model is derived from this orientation. For every face, each edge is split and oriented accordingly. On  the bottom right, we can see those oriented edges (or darts), which are duplicated for edges that are shared by two faces (inner edges).</p> <p></p> <p>The full 2-C-map is depicted below</p> <p></p>"},{"location":"cmap/#implementation-choices","title":"Implementation choices","text":"<p>In order to represent 2D meshes with 2-C-map, we consider a data structue with 2 layers: - A cellular level that we traditionally handle. We have nodes and faces. Nodes have (x,y) coordinates and a face is built from an ordered list of nodes. - A topological level, which is a 2-C-map.</p> <p>Those 2 levels are interconnected: 1. Each node and each face knows/stores the id of a dart that defines it; 2. Each dart stores the id of the node it starts from and the face it belongs to, plus the id of the dart reached by beta1 and beta2. </p>"},{"location":"design/","title":"What to do in this project?","text":""},{"location":"design/#triangular-mesh-adaptation","title":"Triangular mesh adaptation","text":"<p>In order to learn how to modify a 2D mesh, we first implement a 2D game that works on pure triangular meshes. Starting from a 2D mesh, the goal  of the player is to modify the mesh by applying topological operations  in order to improve the mesh quality. Here the quality is based  on topological criteria only. More precisely, we consider the degree  of nodes. The degree of a node is defined as its number of adjacent  faces. Ideally: - The degree of an inner node is 6, - The degree of a boundary node n depends on the local geometry  around n.</p>"},{"location":"design/#version-1-triangles-and-edge-flip","title":"Version 1 - Triangles and edge flip","text":"<p>In the first version, we have only one  operation - the edge flipping - and we provide triangular meshes for which we know what the best solution is. The aim of the intelligent agent we develop is to build this best  solution in a mininum number of movements.</p>"},{"location":"observation/","title":"Observation","text":""},{"location":"observation/#with-quality-observation","title":"With quality observation","text":"<p>We want to observe the mesh in order to choose an appropriate action to improve mesh regularity.</p>"},{"location":"observation/#nodes-scores","title":"Nodes scores","text":"<p>The first aspect to consider is the nodes scores. A node's score is defined as the difference between its ideal adjacency and its actual adjacency:</p> <p>$$ s_n = d_i - d_a $$</p> <p>where  $s_n$ is the score of vertex $n$, $d_i$ is its ideal adjacency, and $d_a$ is its actual adjacency.</p>"},{"location":"observation/#geometrical-quality","title":"Geometrical quality","text":""},{"location":"observation/#we-accept-only-3-configurations","title":"We accept only 3 configurations :","text":"<p>The quadrilaterals shown in Figures (a), (b), and (c) are, respectively, convex, concave, and \"triangular\". These configurations are distinguished by the orientation of their internal angles and the behavior of their diagonals.</p> <ul> <li> <p>A convex quadrilateral is characterized by all internal angles being oriented in the clockwise direction. Equivalently, for each pair of consecutive edges, the signed cross product is strictly negative in a positively oriented coordinate system. In this case, the two diagonals intersect within the interior of the quadrilateral.</p> </li> <li> <p>A concave quadrilateral has exactly one internal angle oriented in the counterclockwise direction. For instance, in figure (b), this can be expressed as:</p> </li> </ul> <p>$$   -\\vec{d_{11}} \\wedge \\vec{d_{21}} &gt; 0   $$</p> <p>In this configuration, the diagonals do not intersect inside the quadrilateral.</p> <ul> <li>A \"triangular\" quadriateral occurs when two adjacent edges are colinear, that is:</li> </ul> <p>$$   -\\vec{d_{11}} \\wedge \\vec{d_{21}} = 0   $$</p>"},{"location":"observation/#all-other-configurations-are-not-supported","title":"All other configurations are not supported:","text":"<p>The quadrilaterals shown in Figures (a), (b), and (c) are, respectively, crossed, flat, and \"half-flat\". These configurations are also distinguished by the orientation of their internal angles and the cross products.</p> <ul> <li> <p>A crossed quadrilateral is characterized by two internal angles being oriented in the clockwise direction and two oriented in the other direction. Equivalently, for each pair of consecutive edges, two signed cross product are strictly negative in a positively oriented coordinate system and two are positive.</p> </li> <li> <p>A flat quadrilateral is characterized by all cross products null.</p> </li> </ul> <p>In this configuration, the diagonals do not intersect inside the quadrilateral.</p> <ul> <li>A half flat quadriateral occurs when two adjacent edges of the same triangular face are colinear, that is:</li> </ul> <p>$$   -\\vec{d_{11}} \\wedge \\vec{d_{21}} = 0   $$</p>"},{"location":"observation/#conclusion","title":"Conclusion","text":"<p>So we charaterized each dart surrounding by its quad associated as :</p> Type boundary convex concave triangular not defined not supported classification id -1 0 1 2 -99 3,4,5"},{"location":"dev/tools/","title":"Some development tips","text":""},{"location":"dev/tools/#tools-to-use","title":"Tools to use","text":"<p>In order to contribute to this project, we suggest to download and/or use: - Pycharm as a Python IDE. The community edition is sufficient for this project; - Python 3 and some python packages like numpy and pygame; - To draw pictures, you can use the version of Excalidraw that integrates LateX support; - The documentation is built using MkDocs. To complete the documentation, you can add content in the documentation directory, and the documentation website will be updated when a branch  is merged in the main branch of tune. If you want to see the documentation in your own computer, you can use the <code>mkdocs serve</code> command (see here for a first example).</p>"},{"location":"dev/tools/#github-procedure","title":"Github procedure","text":"<p>We use merge/pull request to accept contributions. In other words, if you want to contribute to the tune project,  you have to develop in your own branch and ask for a merge request onto the main branch.</p>"},{"location":"tests/actions/","title":"Actions tests","text":""},{"location":"tests/actions/#triangular-actions","title":"Triangular actions","text":""},{"location":"tests/actions/#flip","title":"Flip","text":"<p>We want to ensure that flip operations are performed correctly. Consider the following mesh:</p> <p></p> <p>If we flip the dart between nodes n0 and n3, we should obtain the following mesh:</p> <p></p>"},{"location":"tests/actions/#split","title":"Split","text":"<p>We want to ensure that split operations are performed correctly. Consider the following mesh:</p> <p></p> <p>If we split the dart between nodes n0 and n3, we add a node n5 on the middle of the edge and two faces are created.  We should obtain the following mesh:</p> <p></p>"},{"location":"tests/actions/#collapse","title":"Collapse","text":"<p>We want to ensure that split operations are performed correctly. Consider the following mesh:</p> <p></p> <p>Here we can't collapse the dart between nodes n5 and n2 because n2 is on boundary. However we can collapse the edge between n4 and n5. We should obtain the following mesh:</p> <p></p>"}]}